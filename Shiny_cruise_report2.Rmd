---
output: 
  word_document:
    fig_caption: yes 
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE)
```

```{r global options, include=FALSE}
#set root directory
#opts_knit$set(root.dir="//Client/U$/TEMP")
```

```{r,BaseStats, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE}
library(ECSASconnect)
library(GeoAviR)
require(MASS)
require(knitr)
require(rgdal)
library(png)
library(grid)
require(maptools)
library(RColorBrewer) 
library(dplyr)
library(rgeos)

##adapt species names 
Observation.df$English <- as.factor(Observation.df$English)

if(length(grep("Genus", levels(Observation.df$English))) >=1 ){
  index.genus <- grep("Genus", levels(Observation.df$English))
  new.genus.labs <- sapply(1:length(index.genus),function(i){
    paste(strsplit(levels(Observation.df$English)[index.genus[i]], ": ")[[1]][2],"sp.", "")})
    levels(Observation.df$English)[index.genus] <- new.genus.labs
  names(Observation.df$English)[index.genus]<-  new.genus.labs
} 

if(length(grep("Family", levels(Observation.df$English))) >=1 ){
  index.family <- grep("Family", levels(Observation.df$English))
  new.family.labs <- sapply(1:length(index.family),function(i){
    paste(strsplit(levels(Observation.df$English)[index.family[i]], ": ")[[1]][2],"sp.", "")})
  levels(Observation.df$English)[index.family] <- new.family.labs
  names(Observation.df$English)[index.family]<-  new.family.labs
  } 

freq.sp <- table(Observation.df$English) 

###agregation Densities
total_km_watch.df <- aggregate(WatchLenKm~WatchID,data =Observation.df, FUN=mean, na.rm=T)
total_birds_watch.df <- aggregate(Count~WatchID,data =Observation.df, FUN=sum, na.rm=T)
total.df <- join(total_km_watch.df, total_birds_watch.df, by="WatchID")
###fill watch without observations with zeroes
total.df$Count[is.na(total.df$Count)] <- 0
total.df$Densities <-  total.df$Count/total.df$WatchLenKm

###agregation species
total_birds_sp.df <- aggregate(Count~English,data =Observation.df, FUN=sum, na.rm=T)
#add factor CR
total_birds_sp.df$English <- as.factor(total_birds_sp.df$English)
mean_birds_sp.df <- aggregate(Count~English,data =Observation.df, FUN=mean, na.rm=T)
#add factor CR
mean_birds_sp.df$English <- as.factor(mean_birds_sp.df$English)
sd_birds_sp.df <- aggregate(Count~English,data =Observation.df, FUN=sd, na.rm=T)
#add factor CR
sd_birds_sp.df$English <- as.factor(sd_birds_sp.df$English)

##group size
birds.df <- join(mean_birds_sp.df, sd_birds_sp.df, by ="English")
names(birds.df) <- c("English", "mean", "sd")
birds.df$cv <- birds.df$sd/birds.df$mean
###change name for text
total_birds_sp.df$English <- as.factor(total_birds_sp.df$English)

#drop single observation species
birds.df <- birds.df[!is.na(birds.df$cv),]

#descriptives
observer <- paste(strsplit(levels(Observation.df$ObserverID),"_")[[1]][2], strsplit(levels(Observation.df$ObserverID),"_")[[1]][1], sep=" ")
vessel <- levels(as.factor(Observation.df$PlatformText))
date1 <- paste(substr(unique(Observation.df$StartDate),9,10),month.name[as.numeric(substr(unique(Observation.df$StartDate),6,7))],sep=" ")
date2 <- paste(substr(unique(Observation.df$EndDate),9,10),month.name[as.numeric(substr(unique(Observation.df$EndDate),6,7))], substr(unique(Observation.df$StartDate),1,4),sep=" ")

```
## Report on Seabirds at-sea data collection

_______________________________________________________________________________________________
**`r observer`**

**On the `r vessel`**

**From `r date1` to `r date2`**

#######

Prepared by: `r author`

Environment Canada, Canadian Wildlife Service

`r today`
_______________________________________________________________________________________________


##Background

The east coast of Canada supports millions of breeding marine birds as well as migrants from the southern hemisphere and northeastern Atlantic. In 2005, the Canadian Wildlife Service (CWS) of Environment Canada initiated the Eastern Canada Seabirds at Sea (ECSAS) program with the goal of identifying and minimizing the impacts of human activities on birds in the marine environment.  Since that time, a scientifically rigorous protocol for collecting data at sea and a sophisticated geodatabase have been developed, relationships with industry and DFO to support offshore seabird observers have been established, and over 100,000 km of ocean track have been surveyed by CWS-trained observers.  These data are now being used to identify and address threats to birds in their marine environment. In addition, data are collected on marine mammals, sea turtles, sharks, and other marine organisms when they are encountered.

##Methods
Seabird and marine mammal surveys were conducted from the port side of the bridge of the `r vessel` from `r date1` to `r date2` by `r observer`. Surveys were conducted while the ship was moving at speeds greater than 4 knots, looking forward and scanning a 90 degree arc to one side of the ship.  All birds observed on the water within a 300 m-wide transect were recorded, and we used the snapshot approach for flying birds (intermittent sampling based on the speed of the ship) to avoid overestimating abundance of birds flying in and out of transect.  Distance sampling methods were incorporated to address the variation in bird detectability. Details of the methods used can be found in the CWS standardized protocol for pelagic seabird surveys from moving platforms. 

##Results

###Seabird Sightings

We surveyed `r round(sum(total_km_watch.df$WatchLenKm))` km of ocean from `r date1` to `r date2`. During the survey, a total of `r sum(Observation.df$Count, na.rm=T)` birds were observed in `r as.numeric(table(!is.na(Observation.df$Count))[2])` (`r round(as.numeric(table(!is.na(Observation.df$Count))[2])/nrow(Observation.df)*100)`%) of the `r nrow(Observation.df)` surveyed 5-min periods. The observations were distributed across `r length(levels(as.factor(Observation.df$English)))` species/genus (Table 1) and flock size ranged from `r min(Observation.df$Count, na.rm=T)` to `r max(Observation.df$Count, na.rm=T)` birds.  

```{r, Table1, results='asis' , echo=FALSE, warning=FALSE, message=FALSE,cache=FALSE }
#table1.df <- NULL
table1.df <- join(data.frame(English=names(freq.sp), Flocks=as.numeric(freq.sp)),
                  total_birds_sp.df, by="English")

table1.df$mean <- round(table1.df$Count/table1.df$Flocks,1)
names(table1.df)[names(table1.df)=="Count"]<-"Birds"
names(table1.df)[names(table1.df)=="mean"]<-"Mean flock size"
table1.df <- table1.df[order(-table1.df$Birds),]

```

Table 1: Numbers of flocks, total number of birds, and mean flock size by species

```{r,Table1Out, results='asis' , echo=FALSE, warning=FALSE, message=FALSE, fig.align='center',cache=FALSE }
kable(table1.df, row.names=FALSE)

```

The `r dimnames(freq.sp)[[1]][order(freq.sp,  decreasing=TRUE)][1]` was most common species, accouting for `r round(freq.sp[order(freq.sp,  decreasing=TRUE)][1]/sum(freq.sp)*100,2)`% of the observed flocks (Table 1), followed by the `r dimnames(freq.sp)[[1]][order(freq.sp,  decreasing=TRUE)][2]` (`r round(freq.sp[order(freq.sp,  decreasing=TRUE)][2]/sum(freq.sp)*100,2)`%), and the `r dimnames(freq.sp)[[1]][order(freq.sp,  decreasing=TRUE)][3]` (`r round(freq.sp[order(freq.sp,  decreasing=TRUE)][3]/sum(freq.sp)*100,2)`%).

The largest flock observed was one of `r Observation.df$English[which.max(Observation.df$Count)]`, numbering `r Observation.df$Count[which.max(Observation.df$Count)]` individiuals. Overall, `r birds.df$English[order(birds.df$mean, decreasing=TRUE)][1]` showed the highest average flock size ($\bar{x}$ = `r round(birds.df$mean[order(birds.df$mean, decreasing=TRUE)][1],2)`; sd=`r round(birds.df$sd[order(birds.df$mean, decreasing=TRUE)][1],2)`; Table 1), followed by the `r birds.df$English[order(birds.df$mean, decreasing=TRUE)][2]`($\bar{x}$ = `r round(birds.df$mean[order(birds.df$mean, decreasing=TRUE)][2],2)`; sd=`r round(birds.df$sd[order(birds.df$mean, decreasing=TRUE)][2],2)`), and `r birds.df$English[order(birds.df$mean, decreasing=TRUE)][3]`($\bar{x}$ = `r round(birds.df$mean[order(birds.df$mean, decreasing=TRUE)][3],2)`; sd=`r round(birds.df$sd[order(birds.df$mean, decreasing=TRUE)][3],2)`).

The`r as.character(total_birds_sp.df$English[order(total_birds_sp.df$Count, decreasing=TRUE)][1])` was the most abundant species (Table 1), accounting for `r round(total_birds_sp.df$Count[order(total_birds_sp.df$Count, decreasing=TRUE)][1]/sum(total_birds_sp.df$Count)*100,2)`% of the birds observed (Table 1), followed by the `r as.character(total_birds_sp.df$English[order(total_birds_sp.df$Count, decreasing=TRUE)][2])` (`r round(total_birds_sp.df$Count[order(total_birds_sp.df$Count, decreasing=TRUE)][2]/sum(total_birds_sp.df$Count)*100,2)`%) and the `r as.character(total_birds_sp.df$English[order(total_birds_sp.df$Count, decreasing=TRUE)][3])` (`r round(total_birds_sp.df$Count[order(total_birds_sp.df$Count, decreasing=TRUE)][3]/sum(total_birds_sp.df$Count)*100,2)`%).  

###Seabird detection
```{r, Qualifier, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE}
total_birds_bin.df <- aggregate(Count~Distance,data =Observation.df, FUN=sum, na.rm=T)
###extract order to test
bin.order <- paste(order(total_birds_bin.df[,2]*c(1,1,0.5,0.5), decreasing = TRUE), collapse="")

possible.outcome <- c(paste(c(1,2,3,4), collapse=""),
                      paste(c(2,1,3,4), collapse=""),
                      paste(c(1,2,4,3), collapse=""),
                      paste(c(2,1,4,3), collapse=""))

qualifier <- c("excellent", "average", "good", "mediocre", "unsuitable")

###table observation
Dist_sp.tbl <- table(Observation.df$English,Observation.df$Distance)

#Id species with enough info
keep.sp <- which(apply(Dist_sp.tbl,1,sum)>50)
###qualify detection process
bin.sp <- sapply(1:length(keep.sp),  function(i)paste(order(Dist_sp.tbl[keep.sp[i],]*c(1,1,0.5,0.5), decreasing=TRUE), collapse=""))
qualify.sp <- sapply(1:length(keep.sp), function(i) qualifier[match(bin.sp[i],possible.outcome)[1]])

```


```{r,detection model, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

Observation.df$STR_AREA <- sum(total_km_watch.df$WatchLenKm)*0.3 

all.dist <-distance.wrap(Observation.df, SMP_EFFORT="WatchLenKm",
                         DISTANCE="Distance",SIZE="Count",
                         units=list(Type="Line",Distance="Perp",Length_units="Kilometers",
                                    Distance_units="Meters",Area_units="Square kilometers"),
                         breaks=c(0,50,100,200,300), STR_LABEL="STR_LABEL", 
                         STR_AREA="STR_AREA", SMP_LABEL="WatchID", 
                         path="analysis/temp",
                         pathMCDS="tools",verbose=FALSE)

all.sp.best <- keep.best.model(all.dist)

model.names <-c("uniform","uniform","half-normal","half-normal","hazard rate","hazard rate")
adj.names <- c("cosinus","polynomial","cosinus","hermite polynomial", "cosinus", "polynomial")
mod.selected <- which.min(sapply(1:6, function(i)all.dist[[i]]$AIC[3])) 

####Extract the probability of detection
table3.df <- all.sp.best$parameter_estimates$Global[,-1]
table3.df[,-1] <- round(table3.df[,-1],2)

p.line <- which(table3.df$Parameters=="p")

###extract prediction
table4.df <- all.sp.best$ density_estimate$Global
table4.df[,-c(1,2)] <- round(table4.df[,-c(1,2)],2)
d.line <- which(table4.df$Parameters=="D")
N.line <- which(table4.df$Parameters=="N")

```


```{r, DetectionFigure, echo=FALSE, warning=FALSE, message=FALSE,cache=FALSE, include=FALSE}

pred.df <- data.frame(x=all.sp.best$detection[['Global']][,'distance'],
                      y=all.sp.best$detection[['Global']][,'predicted'])

fig3 <- predicted_hist(all.sp.best)

# 
# fig1 <- predicted_hist(Observation.df, Count="Count", Dist.class="Distance", 
#                   Keep.class=c("25", "75", "150", "250"), 
#                   Breaks=c(0,50,100,200,300), color="grey",
#                   rescale=(total_birds_bin.df[1,2]/max(total_birds_bin.df[,2])))
# 
# 
# fig3 <- fig1 + geom_line(data=pred.df, 
#                          aes(x=x,y=y, xmin=0, xmax=300, ymin=0, ymax=1), 
#                          linetype=1, size=1.25) +
#                           xlab("Distance (m)") +
#                           ylab("Detection Probability")+
#                           ylim(0,1)

#png("detection.png",width=480,height =480,units="px",antialias = "cleartype",type="cairo")
png("detection.png",width=480,height =480,units="px")
print(fig3)
invisible(dev.off())

```

![Figure 1: Detection function of all species combined in function of the distance bins (line) with observations by distance bins](detection.png "Detection Plot")


The distance sampling model best describing how the number of seabird observations varied with the perpendicular distance from the ship was a `r model.names[mod.selected]` with a `r adj.names[mod.selected]` adjustement. The estimated probability of detection was `r table3.df[p.line,2]` (95%CI:`r paste(table3.df[p.line,5],table3.df[p.line,6], sep=" - ")`; Figure 1) within the 300 meter width of the transect. The model predicted a density of `r table4.df[d.line,3]` (95%CI:`r paste(table4.df[d.line,6],table4.df[d.line,7], sep=" - ")`) seabirds/$km^2$ along the ship path. Note that this model doesn't account for potential different detection probabilities among species or effects of daily conditions.    


###Seabird distribution
```{r, Grid, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}
 
#####create grid with bounding box

### faire un shapefile ? partir des d?but d'observations dans les donn?es
d <- Observation.df
transect <- data.frame(lat=d$LatStart,lon=d$LongStart)
coordinates(transect) <- ~lon + lat
transect<-SpatialPointsDataFrame(transect,data=d)
proj4string(transect)<-CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

# dist_res <- "U:/Oiseaux souill?s/Inventaires p?lagiques/GeoAviR/Cruise_report"
# setwd(dist_res)


#### earth background
shpm <- readOGR("./maps","ne_10m_land")

###mettre les donn?es et le fond de carte ensemble - assurer la m?me projection au cas o?
prj <- proj4string(transect)
shpm<-spTransform(shpm,CRS(prj)) 

#create study area using a bounding box
b <- bbox(transect)
b[,2] <- b[,2]+1 #need larger buffer than just min max, with 50 km grid cell
b[,1] <- b[,1]-1 #need larger buffer than just min max, with 50 km grid cell

### Build a 50000 x 50000 meters grid - lat et long ? partir du jeu de donn?es? on voir plus tard avec plot(transect) que la grille sert aussi ? restreinfre l'?tendue spatiale
size<-50000
new.grid<-create.grid(Latitude=c(b[2,1],b[2,2]),Longitude=c(b[1,1],b[1,2]),Grid.size=c(size,size),Clip=F,clip.shape=shpm,projection=CRS(prj))
new.grid$ID<-paste("parc",new.grid$ID,sep="")

#selectionner les cellules visit?es et couper le shp avec le continent
new.grid<-new.grid[apply(gIntersects(transect,new.grid,byid=TRUE),1,any),] #limitation de taille de vecteur?

#couper les cellules qui overlap avec le continent
#     if(!is.na(any(over(new.grid, shpm,)))){
#       polydata <- new.grid@data
#       test2 <- new.grid[which(over(new.grid, shpm, byid = T)==1),]#select cells that overlay the continent
#       test <- gDifference(test2, shpm, byid = T)# note: may take several minutes
#       test3 <- new.grid[which(is.na(over(new.grid, shpm, byid = T)==1)),]#select cells that DO NOT overlay 
#       new.grid <- spRbind(test, test3 ) 
#       row.names(new.grid) <- row.names(polydata)
#       new.grid <- SpatialPolygonsDataFrame(new.grid,data=polydata)
#     }

```


```{r, Join data to grid shp, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

##compute cell/zone area (km2)
#needs lambert projection for distance
prjm <- "+proj=lcc +lat_1=46 +lat_2=60 +lat_0=44 +lon_0=-68.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"
test<-spTransform(new.grid,CRS(prjm))
area <- data.frame(km2=gArea(test,byid=T)/1000000)
area$ID <- 1:nrow(area)
area$ID <- paste("parc",area$ID,sep="")
test <- SpatialPolygonsDataFrame(test,data=area)
new.grid<-spTransform(test,CRS(prj)) 

```


```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

### Overlay transects and grid and attribute squares to observations
x<-over(transect,new.grid)
d$square<-x$ID
d$square_area <- x$km2
d<-d[!is.na(d$square),]

sample <- names(d)[4] #"Date" #Select variable WatchID, or Date or else
d$SMP_LABEL<-paste(d$square,d[,c(sample)],sep="_")

### Construct sample labels considering that day transects can overlap with multiple squares
temp<-aggregate(WatchLenKm~SMP_LABEL,data=unique(d[,c("SMP_LABEL","WatchID","WatchLenKm")]),sum)
names(temp)[2]<-"SMP_EFFORT"
d<-merge(d,temp,sort=FALSE)

```


```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

d<-d[,c("square","square_area","Date","SMP_LABEL","SMP_EFFORT","Distance","Count","Alpha")]

```


```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

dd<-d %>% group_by(SMP_LABEL) %>% summarise(V1=sum(Count,na.rm=TRUE))

```


```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}
dd<-dd[dd$V1==0,] #get the label name for transect without observations
```



```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}
d<-d[(d$SMP_LABEL%in%dd$SMP_LABEL & !duplicated(d$SMP_LABEL)) | (!d$SMP_LABEL%in%dd$SMP_LABEL & !(d$Alpha=="")),] #keep only lines for empty transects or non-empty lines for non-empty transects
```

```{r, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}
d<-d[order(d$square),]

```

```{r, SelectedModel, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, include=FALSE}

###distance sampling w/spatial strat
path<-"analysis/temp"
pathMCDS<-"tools"
breaks<-c(0,50,100,200,300)#un peu redondant avec filtre/donn?es
SMP_LABEL<-"SMP_LABEL"
SMP_EFFORT<-"SMP_EFFORT"
DISTANCE<-"Distance"
SIZE<-"Count"
STR_LABEL<-"square"
STR_AREA<-"square_area"
split<-F
stratum<-"STR_LABEL"
detection<-"All"
empty<-NULL
keep.me = which.min(sapply(1:length(all.dist), function(i){all.dist[[i]]$AIC[3]}))#model selected
key <- sapply(strsplit(names(all.dist)[keep.me],"_"),"[",2)
exp <- sapply(strsplit(names(all.dist)[keep.me],"_"),"[",3)
estimator=list(c(key,exp))
units=list(Type="Line",Distance="Perp",Length_units="Kilometers",
           Distance_units="Meters",Area_units="Square kilometers")

#analyse- calcul des densit?es telles que demand?es
x<-distance.wrap(d,estimator=estimator,units=units,stratum=stratum,empty=empty,detection=detection,split=split,path=path,pathMCDS=pathMCDS,breaks=breaks,STR_LABEL=STR_LABEL,STR_AREA=STR_AREA,SMP_LABEL=SMP_LABEL,SMP_EFFORT=SMP_EFFORT,DISTANCE=DISTANCE,SIZE=SIZE,verbose=FALSE)

#get dist sampling model density estimates
path1 <- paste("x$","density_estimate$Stratum",sep="")#model without strat
assign("tmp",eval(parse(text=path1)))

######si aucun sous-groupe = x$density_estimate$Stratum#####

densities <- tmp[tmp$Parameters == "D",c("Stratum","Estimates","% of var.")]

####save shp - grille + donn?es assoc?es aux cellules
densities$Estimates <- as.numeric(densities$Estimates)
names(densities)[3] <- "CoefVar" #probleme avec % dans nom
densities$CoefVar <- as.numeric(densities$CoefVar)
names(densities)[names(densities) == "Stratum"] <- "ID"

#join les estimations aux shp des cellules
o <- match(new.grid$ID, densities$ID) #IDs for new.grid before??
temp <- densities[o,]
row.names(temp) <- row.names(new.grid)
new.grid2 <- spCbind(new.grid,temp)
new.grid2 <- new.grid2[!is.na(new.grid2$Estimates),] #enlever les cellules non visit?es dans le subset
test <- new.grid2@data

#select variable to map
#names(new.grid2@data)
map <- names(new.grid2@data)[4] #or else
temp <- densities[densities$Estimates>0,]
brks <- quantile(temp[,c(map)], c(0,.5,.75,.95))

#table(new.grid2@data[,c(map)])

brks[1] <- ifelse(brks[1]!=0,0,brks[1])#needed for data below first rounded class
brks[length(brks)+1] <- max(new.grid2@data[,c(map)])+0.1
brks <- round(brks,1)#3 is no good

##associate data w/brks intervals
tags<-vector()
for (i in 1:length(brks)) {
  if (i ==1 ) {
    new.grid2@data$class  <- ifelse(new.grid2@data[,c(map)] == brks[i], as.character(brks[i]),"-")
    new.grid2@data$classno  <- ifelse(new.grid2@data[,c(map)] == brks[i], as.numeric(i),"-")
    tags[1]<- as.character(brks[i])
    
  }
  if(i>1) {
    new.grid2@data$class  <- ifelse(new.grid2@data[,c(map)] > brks[i-1] & new.grid2@data[,c(map)] <= brks[i], paste(" > ",brks[i-1]," - ",brks[i],sep=""), new.grid2@data$class)
    new.grid2@data$classno  <- ifelse(new.grid2@data[,c(map)] > brks[i-1] & new.grid2@data[,c(map)] <= brks[i], as.numeric(i), new.grid2@data$classno)
    tags[i]<- paste(" > ",brks[i-1]," - ",brks[i],sep="")
  }
}
classes <- unique(new.grid2$class[!is.na(new.grid2$class)])

#colors for legend
br.palette <- colorRampPalette(c("green","yellow", "red"), space = "rgb")
nb<- length(brks)-1 
br.palette(nb)
pal <- br.palette(n=nb)
pal <- c("lightgray",pal)#ajout class 0
new.grid2$color <- pal[as.numeric(new.grid2$classno)]

legendtitle <- "birds/km2"
new.grid2$classno <- as.numeric(new.grid2$classno)
new.grid2 <- new.grid2[order(new.grid2$classno),]
 
```

```{r, Map,echo=FALSE, warning=FALSE, message=FALSE,cache=FALSE, include=FALSE}

 ##plot map
png("Fig4.png",width=960,height=960,antialias = "cleartype",units="px")
  plot(new.grid2,bg="lightblue",border="lightblue",axes=T,cex.axis=1.5)
  for (i in 1:length(classes)){
    plot(new.grid2[new.grid2$class[!is.na(new.grid2$class)]==classes[i],],col=new.grid2@data[new.grid2$class[!is.na(new.grid2$class)]==classes[i],"color"],border="darkgray",add=T)
  }
  plot(shpm,add=T,col="darkkhaki",border="darkkhaki",axes=T)
  plot(transect,col="darkgray",pch=16,cex=1,add=T)
  legend("bottomright", bty = "n",  legend = tags,fill=pal, title=legendtitle,cex=1.5)
  legend( "bottomleft", bty = "n",cex=1.5,
          legend=c("Locations of 5-min observation periods"),
          col="darkgray", pch=16 )
invisible(dev.off())
 
 new.grid2$abun <- new.grid2$km2 * new.grid2$Estimates

```


 ![Figure 2: Seabird density by 50x50 km cell where observations were conducted, given the selected detection model](Fig4.png "Distribution Plot")
 
Following the spatial post-stratification of the selected distance model, there were `r nrow(new.grid2[new.grid2$classno==2,])` grid cells with densities below the 50% quantile, `r nrow(new.grid2[new.grid2$classno==3,])` cell(s) between the latter and the 75% quantile, `r nrow(new.grid2[new.grid2$classno==4,])` cell(s) between the latter and the 95% quantile, and `r nrow(new.grid2[new.grid2$classno==5,])` cell(s) in the top 5% quantile (Fig. 4). Given the visited cells corresponded to the study area, we estimated the total seabird population at `r sum(new.grid2@data$abun)` during the cruise.
